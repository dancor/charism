module Util where

import Data.Char
import Data.Bits
import Data.Either
import Data.List
import Locale
import System
import System.IO
import System.Random
import System.Time

-- not in yet

intercalate :: [a] -> [[a]] -> [a]
intercalate s l =
  concat $ intersperse s l
interlines = intercalate "\n"
interwords = intercalate " "

on :: (a -> a -> b) -> (c -> a) -> c -> c -> b
on op f x y = op (f x) (f y)

-- danl made-up

frep :: (a -> a) -> Int -> a -> a
frep f n x = iterate f x !! n

padl :: a -> Int -> [a] -> [a]
padl c l s = replicate (l - length s) c ++ s

padr :: a -> Int -> [a] -> [a]
padr c l s = s ++ replicate (l - length s) c

splitN :: Int -> [b] -> [[b]]
splitN _ [] = []
splitN n xs = l : splitN n r where (l, r) = splitAt n xs

logTimeStr :: IO String
logTimeStr = do
  t <- getClockTime
  let ct = toUTCTime t in
    return $ (formatCalendarTime defaultTimeLocale "%Z %Y-%m-%d %H:%M:%S" ct) ++ "." ++ (padl '0' 12 $ show $ ctPicosec ct)

-- pythonic list slicing
slice :: Int -> Int -> [a] -> [a]
slice x y l = take (y - x) $ drop x l

-- stripe one list across n of them
stripe :: Int -> [a] -> [[a]]
stripe n = reverse . foldr (\x (ys:yss) -> yss ++ [x:ys]) (replicate n [])

startsWith :: Eq a => [a] -> [a] -> Bool
startsWith xs [] = True
startsWith [] ys = False
startsWith (x:xs) (y:ys) =
  (x == y) && startsWith xs ys

-- cyclic successor on an enum
cycSucc :: (Eq a, Bounded a, Enum a) => a -> a
cycSucc x = if x == maxBound then minBound else succ x

-- cycle a list one element forward
cyc :: [a] -> [a]
cyc (x:xs) = xs ++ [x]
-- cycle a list one element back
cycB :: [a] -> [a]
cycB xs = reverse $ cyc $ reverse xs

-- try to get user input until input-parsing fcn succeeds
repInp :: String -> (String -> Either String a) -> IO a
repInp dispStr parseFcn = do
  putStr dispStr
  hFlush stdout
  s <- getLine
  case parseFcn s of
    Left err -> do
      putStrLn err
      repInp dispStr parseFcn
    Right ret -> do
      return ret

sublistIx :: Eq a => [a] -> [a] -> Maybe Int
sublistIx subl l = findIndex id $ map (isPrefixOf subl) (tails l)

subst :: Eq a => [a] -> [a] -> [a] -> [a]
subst _ _ [] = []
subst from to xs@(a:as) =
  if isPrefixOf from xs
    then to ++ subst from to (drop (length from) xs)
    else a : subst from to as

isLeft :: Either a b -> Bool
isLeft e =
  case e of
    Left l -> True
    Right r -> False
isRight :: Either a b -> Bool
isRight e =
  case e of
    Left l -> False
    Right r -> True

chooseR :: [a] -> IO (a)
chooseR l = do
  let n = length l
  i <- randomRIO (0, n - 1)
  return $ l!!i

timePDiff :: ClockTime -> ClockTime -> Integer
timePDiff (TOD xs xp) (TOD ys yp) = (xs - ys) * 1000000000000 + xp - yp

lookupWithKey :: Eq a => a -> [(a, b)] -> Maybe (a, b)
lookupWithKey k l = case lookup k l of
  Just v -> Just (k, v)
  Nothing -> Nothing

clrScr :: IO ()
clrScr = do
  system "clear"
  return ()

mapAccum :: (a -> Int -> b) -> [a] -> [b]
mapAccum = mapAccumFromN 0 where
  mapAccumFromN :: Int -> (a -> Int -> b) -> [a] -> [b]
  mapAccumFromN n f l = case l of
    [] -> []
    (x:xs) -> [f x n] ++ (mapAccumFromN (n + 1) f xs)

pSecInSec = 1000 ^ 4

-- how is this not done for me by ghc
-- Convert Unicode characters to UTF-8.
toUtf :: String -> String
toUtf [] = []
toUtf (x:xs) | ord x<=0x007F = x:toUtf xs
             | ord x<=0x07FF = chr (0xC0 .|. ((ord x `shift` (-6)) .&. 0x1F)):
                               chr (0x80 .|. (ord x .&. 0x3F)):
                               toUtf xs
             | otherwise     = chr (0xE0 .|. ((ord x `shift` (-12)) .&. 0x0F)):
                               chr (0x80 .|. ((ord x `shift` (-6)) .&.  0x3F)):
                               chr (0x80 .|. (ord x .&. 0x3F)):
                               toUtf xs

cap :: [a] -> [a] -> [a]
cap c l = c ++ l ++ c

dlof :: a -> [a -> a] -> a
dlof = foldl (flip ($))

fromRight :: Either a b -> b
fromRight (Right x) = x

fromLeft :: Either a b -> a
fromLeft (Left x) = x
