<html>
<head>
<title>charism</title>
<style>
body {
  background: #8bf;
  -webkit-user-select: none;
     -moz-user-select: -moz-none;
      -ms-user-select: none;
          user-select: none;
}
</style>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

<script type="text/javascript" src="pickWords.js" charset="utf-8"></script>
<script type="text/javascript">
var noLtr = "@";

var tooltip;
var helpBox;

var ltrNum = 7;
var rack0X = 8;
var rack0Y = 8;
var rack0InterSpaceX = 8;
var rack0InterSpaceY = 8;
var rack0LtrW = 64;
var rack0LtrH = 64;

var rackX = rack0X;
var rackY = rack0Y + rack0LtrH + rack0InterSpaceY;
var rackInterSpaceX = 8;
var rackInterSpaceY = 8;
var rackLtrW = 64;
var rackLtrH = 64;

var cellW = rack0LtrW + rack0InterSpaceX;
var cellH = rack0LtrH + rack0InterSpaceY;

var wdsX = rackX;
var wdsY = rackY + rackLtrH + rackInterSpaceY;
var wdsInterSpaceX = 4;
var wdsInterSpaceY = 4;
var wdsColInterSpaceX = 16;
var wdsLtrW = 32;
var wdsLtrH = 32;

var wdsRowNum = 0;

var showSwap = false;

var rack = [];
/*
var lang = "en";
var langParam = getParam("lang");
*/

var wdsRaw;
var wds;

function last(a) {
    return a[a.length - 1];
}
function ord(c) {
    return c.charCodeAt(0);
}
function chr(i) {
    return String.fromCharCode(i);
}
function strToArr(s) {
    var r = [];
    for (var i = 0; i < s.length; i++) {
        r[i] = s[i];
    }
    return r;
}
function arrToStr(a) {
    return [].concat(a);
}
function shuffle(a) {
    for (var i = a.length - 1; i >= 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var tmp = a[j];
        a[j] = a[i];
        a[i] = tmp;
    }
    return a;
}
function putInFirstEmpty(a, c) {
    for (var i = 0; i < a.length; i++) {
        if (a[i].c == noLtr) {
            ltrSetC(a[i], c);
            return;
        }
    }
    throw("something went wrong in putInFirstEmpty");
}
/*
function getParam(name) {
    // fixme: make this do decoding?
    name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
    var regexS = "[\\?&]" + name + "=([^&#]*)";
    var regex = new RegExp(regexS);
    var results = regex.exec(window.location.href);
    if (results == null) {
        return null;
    } else {
        return results[1];
    }
}
*/
function createLtr(x, y, ltrW, ltrH, c) {
    var img = document.createElement("img");
    img.src = "img/" + c + ".png";
    img.width = ltrW;
    img.height = ltrH;
    img.style.position = "absolute";
    img.style.left = x;
    img.style.top = y;
    document.body.appendChild(img);
    return {c: c, img: img};
}
function createLtrs(x, y, ltrW, ltrH, interSpaceW, cs, tooltip) {
    var r = [];
    for (var i = 0; i < cs.length; i++) {
        r[i] = createLtr(x + i * (ltrW + interSpaceW), y, ltrW, ltrH, cs[i]);
    }
    return r;
}
function replicate(n, v) {
    var r = [];
    for (var i = 0; i < n; i++) {
        r[i] = v;
    }
    return r;
}
function ltrSetC(ltr, c) {
    ltr.c = c;
    ltr.img.src = "img/" + c + ".png";
}
function updateLtr(ltr, x, y, w, h, c) {
    ltr.img.width = w;
    ltr.img.height = w;
    ltr.img.style.left = x;
    ltr.img.style.top = y;
    ltrSetC(ltr, c);
}
function updateLtrs(ltrs, x, y, ltrW, ltrH, interSpaceW, cs) {
    for (var i = 0; i < ltrs.length; i++) {
        updateLtr(ltrs[i], x + i * (ltrW + interSpaceW), y, ltrW, ltrH, cs[i]);
    }
}
function ltrsToCs(ltrs) {
    var r = [];
    for (var i = 0; i < ltrs.length; i++) {
        r[i] = ltrs[i].c;
    }
    return r;
}
function rack0ToRack(rack0I) {
    for (var rackI = 0; rackI <= ltrNum; rackI++) {
        if (rack[1][rackI].c == noLtr) {
            ltrSetC(rack[1][rackI], rack[0][rack0I].c);
            break;
        }
    }
    ltrSetC(rack[0][rack0I], noLtr);
}
function rackToBag(rackI) {
    putInFirstEmpty(rack[0], rack[1][rackI].c);
    ltrSetC(rack[1][rackI], noLtr);
}
function rackEndToBag() {
    for (var rackI = 0; rackI < rack[1].length; rackI++) {
        if (rack[1][rackI].c != noLtr) {
            rackToBag(rackI);
        }
    }
}
window.onload = function() {
    tooltip = document.getElementById("tooltip");
    helpBox = document.getElementById("help");
    /*
    if (langParam == "de") {
        lang = "de";
    }
    */
    function showTooltip(x, y, content) {
        tooltip.style.left = 0;
        tooltip.style.top = 0;
        tooltip.innerHTML = content;
        if (x < tooltip.offsetWidth) {
            tooltip.style.left = x;
        } else {
            tooltip.style.left = x - tooltip.offsetWidth;
        }
        if (y < tooltip.offsetHeight) {
            tooltip.style.top = y;
        } else {
            tooltip.style.top = y - tooltip.offsetHeight;
        }
        tooltip.style.visibility = "visible";
    }
    function tooltipify(a, content) {
        a.addEventListener("mouseover", function(e) {
            showTooltip(e.clientX, e.clientY, content);}, true);
        a.addEventListener("mouseout", function(e) {
            tooltip.style.visibility = "hidden";}, true);
    }

    wdsRaw = pickWords();
    createLtrs(rack0X, rack0Y, rack0LtrW, rack0LtrH, rack0InterSpaceX,
        replicate(ltrNum, "_"));
    createLtrs(rackX, rackY, rackLtrW, rackLtrH, rackInterSpaceX,
        replicate(ltrNum, noLtr));
    var shuffledLtrs = shuffle(strToArr(last(wdsRaw)));
    rack = [shuffledLtrs, replicate(ltrNum, noLtr)];
    tiles = createLtrs(rack0X, rack0Y, rack0LtrW, rack0LtrH, rack0InterSpaceX,
        shuffledLtrs);
    function moveTile(srcX, srcY, dstX, dstY) {
        tmp = rack[dstY][dstX];
        rack[dstY][dstX] = rack[srcY][srcX];
        rack[srcY][srcX] = tmp;
        for (var tileI = 0; tileI < ltrNum; tileI++) {
            if (tiles[tileI].x == srcX && tiles[tileI].y == srcY) {
                tiles[tileI].x = dstX;
                tiles[tileI].y = dstY;
                tiles[tileI].img.style.left =
                    dstX * cellW + rack0X;
                tiles[tileI].img.style.top =
                    dstY * cellH + rack0Y;
                break;
            }
        }
    }
    for (var i = 0; i < ltrNum; i++) {
        tiles[i].img.id = "t" + i;
        tiles[i].x = i;
        tiles[i].y = 0;
        var onstart = function(i) {
                tiles[i].img.style.zIndex = 100;
            }.bind(null, i);
        var ondrag = function(i) {
                var fromX = tiles[i].x;
                var fromY = tiles[i].y;
                var imgL = parseFloat(tiles[i].img.style.left);
                var imgT = parseFloat(tiles[i].img.style.top);
                var toX = Math.round((imgL - rack0X) / cellW);
                var toY = Math.round((imgT - rack0Y) / cellH);

                if (toX < 0) {toX = 0;}
                if (toY < 0) {toY = 0;}
                if (toX >= ltrNum) {toX = ltrNum - 1;}
                if (toY > 1) {toY = 1;}

                function tryPushRight() {
                    var foundOpenX = false;
                    for (var openX = toX + 1; openX < ltrNum; openX++) {
                        if (rack[toY][openX] == noLtr) {
                            foundOpenX = true;
                            break;
                        }
                    }
                    if (foundOpenX) {
                        for (var swapX = openX; swapX > toX; swapX--) {
                            moveTile(swapX - 1, toY, swapX, toY);
                        }
                        return true;
                    }
                    return false;
                }
                function tryPushLeft() {
                    var foundOpenX = false;
                    for (var openX = toX - 1; openX >= 0; openX--) {
                        if (rack[toY][openX] == noLtr) {
                            foundOpenX = true;
                            break;
                        }
                    }
                    if (foundOpenX) {
                        for (var swapX = openX; swapX < toX; swapX++) {
                            moveTile(swapX + 1, toY, swapX, toY);
                        }
                        return true;
                    }
                    return false;
                }

                if ((fromX != toX || fromY != toY) && 
                        rack[toY][toX] != noLtr) {
                    if (imgL <= toX * cellW + rack0X) {
                        if (tryPushRight()) {
                            return;
                        } else if (tryPushLeft()) {
                            return;
                        }
                    } else {
                        if (tryPushLeft()) {
                            return;
                        } else if (tryPushRight()) {
                            return;
                        }
                    }
                    // swap
                    moveTile(toX, toY, fromX, fromY);
                    tiles[i].x = toX;
                    tiles[i].y = toY;
                }
            }.bind(null, i);
        var onstop = function(i) {
                var fromX = tiles[i].x;
                var fromY = tiles[i].y;
                var imgL = parseFloat(tiles[i].img.style.left);
                var imgT = parseFloat(tiles[i].img.style.top);
                var toX = Math.round((imgL - rack0X) / cellW);
                var toY = Math.round((imgT - rack0Y) / cellH);
                if (toX < 0) {toX = 0;}
                if (toY < 0) {toY = 0;}
                if (toX >= ltrNum) {toX = ltrNum - 1;}
                if (toY > 1) {toY = 1;}
                tmp = rack[fromY][fromX];
                rack[fromY][fromX] = rack[toY][toX];
                rack[toY][toX] = tmp;
                for (var tileI = 0; tileI < ltrNum; tileI++) {
                    if (tiles[tileI].x == toX && tiles[tileI].y == toY) {
                        tiles[tileI].x = fromX;
                        tiles[tileI].y = fromY;
                        tiles[tileI].img.style.left =
                            fromX * cellW + rack0X;
                        tiles[tileI].img.style.top =
                            fromY * cellH + rack0Y;
                        break;
                    }
                }
                tiles[i].x = toX;
                tiles[i].y = toY;

                tiles[i].img.style.zIndex = 1;
                tiles[i].img.style.left = toX * cellW + rack0X;
                tiles[i].img.style.top = toY * cellH + rack0Y;
                checkIfGotWd();
            }.bind(null, i);
        $("#t" + i).draggable({
            start: onstart,
            drag: ondrag,
            stop: onstop
        });
    }
    wds = [];
    for (var i = 0; i < wdsRaw.length; i++) {
        var def = "loldef";
        wds[i] = {
            ltrs: createLtrs(wdsX, wdsY + i * (wdsLtrH + wdsInterSpaceY), 
                wdsLtrW, wdsLtrH, wdsInterSpaceX, wdsRaw[i]),
            wd: wdsRaw[i],
            got: false,
            def: def
            };
        for (var j = 0; j < wdsRaw[i].length; j++) {
            tooltipify(wds[i].ltrs[j].img, "<b>" + def + "</b>");
            wds[i].ltrs[j].img.onclick = function(wd){
                window.open(
                    //"https://en.wiktionary.org/wiki/" + wd + "#Spanish",
                    "http://localhost:3000/A/" + wd + ".html",
                    "_blank");
            }.bind(null, wdsRaw[i]);
        }
    }
    function resize() {
        var x = wdsX;
        var y = wdsY;
        var wdsLtrWCur = wdsLtrW;
        var wdsLtrHCur = wdsLtrH;
        while (wdsLtrWCur >= 10) {
            var tooBig = false;
            for (var i = 0; i < wds.length; i++) {
                var wdL = wds[i].wd.length;
                if (x + wdL * (wdsLtrWCur + wdsInterSpaceX) - wdsInterSpaceX + 8 >= 
                        window.innerWidth) {
                    tooBig = true;
                    break;
                }
                y += wdsInterSpaceY + wdsLtrHCur;
                if (y + wdsInterSpaceY + wdsLtrHCur > window.innerHeight) {
                    x += wdL * (wdsLtrWCur + wdsInterSpaceX) - wdsInterSpaceX +
                        wdsColInterSpaceX;
                    y = wdsY;
                }
            }
            x = wdsX;
            y = wdsY;
            if (tooBig) {
                wdsLtrWCur--;
                wdsLtrHCur--;
                continue;
            }
            break;
        }
        colWidths = [];
        wdsRowNum = 0;
        for (var i = 0; i < wds.length; i++) {
            var curWd;
            if (wds[i].got ^ showSwap) {
                curWd = wds[i].wd;
            } else {
                curWd = replicate(wds[i].wd.length, noLtr);
            }
            updateLtrs(wds[i].ltrs, x, y, wdsLtrWCur, wdsLtrHCur, wdsInterSpaceX, 
                curWd);
            y += wdsInterSpaceY + wdsLtrHCur;
            if (y + wdsInterSpaceY + wdsLtrHCur > window.innerHeight) {
                var wdW = curWd.length * (wdsLtrWCur + wdsInterSpaceX) - 
                    wdsInterSpaceX;
                colWidths = colWidths.concat([wdW]);
                if (wdsRowNum == 0) {
                    wdsRowNum = i + 1;
                }
                x += wdW + wdsColInterSpaceX;
                y = wdsY;
            }
        }
    }
    function checkIfGotWd() {
        var rackWd = "";
        for (var i = 0; i < ltrNum; i++) {
            if (rack[1][i] != noLtr) {
                rackWd += rack[1][i];
            }
        }
        //console.log(rack[0]);
        //console.log(rack[1]);
        for (var i = 0; i < wds.length; i++) {
            if (wds[i].wd == rackWd) {
                wds[i].got = true;
                //rackEndToBag();
                resize();
                break;
            }
        }
    }
    /*
    function mouseup(whichRack, rackPos) {
        if (curDown) {
            var c = rack[curDown[0]][curDown[1]].c;
            ltrSetC(rack[curDown[0]][curDown[1]], rack[whichRack][rackPos].c);
            ltrSetC(rack[whichRack][rackPos], c);
            curDown = false;
        }
        checkIfGotWd();
        return false;
    }
    */
    function keydown(e) {
        //var i = e.keyCode % 128;
        var i = e.keyCode;
        //console.log(i);
        if (i >= 65 && i <= 90) {
            var c = chr(i).toLowerCase();
            for (var i = 0; i < ltrNum; i++) {
                if (rack[0][i].c == c) {
                    rack0ToRack(i);
                    break;
                }
            }
            checkIfGotWd();
        } else if (i == 8 || i == 92) { // backspace, delete
            for (var i = ltrNum - 1; i >= 0; i--) {
                if (rack[1][i].c != noLtr) {
                    putInFirstEmpty(rack[0], rack[1][i].c);
                    ltrSetC(rack[1][i], noLtr);
                    break;
                }
            }
        } else if (i == 32) { // spacebar to shuffle
            updateLtrs(rack[0], rack0X, rack0Y, rack0LtrW, rack0LtrH,
                rack0InterSpaceX,
                arrToStr(shuffle(strToArr(ltrsToCs(rack[0])))));
        } else if (i == 13) { // enter
            //checkForWd();
        } else if (i == 27) { // escape to clear rack
            rackEndToBag();
        } else if (i % 128 == 63) {
            showSwap = !showSwap;
            resize();
        } else {
            //console.log(i);
        }
        return false;
    }
    window.addEventListener("resize", resize, true);
    window.addEventListener("keydown", keydown, true);
    tooltipify(helpBox, "<b>Use the keyboard to make words:<br>" +
"- Type letters to move letters to your working rack.<br>" + 
"- Press backspace or \\ to move one letter off your working rack.<br>" +
"- Press escape to move all letters off your working rack.<br>" +
"- Press enter when you have made a word.<br>" + 
"- Press spacebar to shuffle the letters on the source rack.<br>" +
"- Pless ? to show words you haven't gotten.<br>" +
"- Hover over words to see definitions.<br>" +
"- Reload the page (ctrl+r) to play another round.</b>");
    resize();
};
</script>
</head>
<body>
<img id="help" src="img/help.png" align="right" />
<!-- todo: tooltip on top -->
<div id="tooltip" style="visibility:hidden;position:absolute;left:0px;top:0px;opacity:0.9;background:yellow;border-style:outset;border-color:orange;word-wrap:break-word;max-width:40em;z-index:100">
</div>
</body>
</html>
